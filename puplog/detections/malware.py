# detections/malware.py
import re
import yaml

def detect_known_bad_filenames(logs):
    """
    Look for known bad filenames or suspicious artifact names in logs.
    """
    try:
        cfg = yaml.safe_load(open("config/rules.yml")) or {}
        bad = cfg.get("bad_filenames", ["bad.bin", "malware", "suspicious.exe", "evil.sh"])
    except Exception:
        bad = ["bad.bin", "malware", "suspicious.exe", "evil.sh"]

    findings = []
    for log in logs:
        msg = log.get("message", "").lower()
        for b in bad:
            if b.lower() in msg:
                findings.append({
                    "timestamp": log.get("timestamp"),
                    "host": log.get("host"),
                    "process": log.get("process"),
                    "message": log.get("message"),
                    "indicator": f"bad_filename:{b}"
                })
    return findings

def detect_unexpected_outbound_connections(logs):
    """
    Flag outbound connections initiated by critical processes (e.g., sshd, nginx, mysqld).
    Look for patterns like 'connected to', 'ESTABLISHED', or 'sending to' with external IPs.
    """
    try:
        cfg = yaml.safe_load(open("config/rules.yml")) or {}
        critical = set(cfg.get("critical_processes", ["sshd", "nginx", "mysqld", "postgres", "httpd"]))
    except Exception:
        critical = {"sshd", "nginx", "mysqld", "postgres", "httpd"}

    findings = []
    for log in logs:
        proc = (log.get("process") or "").lower()
        msg = log.get("message", "")
        # normalize proc name (remove pid)
        proc_name = re.sub(r"\[\d+\]", "", proc).strip()
        for c in critical:
            if c in proc_name:
                if re.search(r"(connected to|connection to|ESTABLISHED|sending to|connect\()", msg, re.IGNORECASE):
                    ip_m = re.search(r"(\d{1,3}(?:\.\d{1,3}){3})", msg)
                    findings.append({
                        "timestamp": log.get("timestamp"),
                        "host": log.get("host"),
                        "process": log.get("process"),
                        "message": msg,
                        "ip": ip_m.group(1) if ip_m else None,
                        "indicator": f"outbound_by_{c}"
                    })
                break
    return findings

def detect_command_injection_patterns(logs):
    """
    Search for web-access logs or shell logs containing common command-injection indicators.
    """
    patterns = [
        r"\.\./", r";\s*", r"\|", r"wget\s+", r"curl\s+", r"bash\s+-i", r"nc\s+-e", r"rm\s+-rf\s+/",
    ]
    compiled = [re.compile(p, re.IGNORECASE) for p in patterns]
    findings = []
    for log in logs:
        msg = log.get("message", "")
        for c in compiled:
            if c.search(msg):
                findings.append({
                    "timestamp": log.get("timestamp"),
                    "host": log.get("host"),
                    "process": log.get("process"),
                    "message": msg,
                    "indicator": f"injection:{c.pattern}"
                })
                break
    return findings
